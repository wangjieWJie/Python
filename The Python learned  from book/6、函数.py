# 随便写了一个求二次函数的根的函数
def solve(a=0, b=0, c=0, x_n=0):
    # abc分别代表三个系数
    if a != 0:
        deerta = b**2 - 4 * a * c  # 先计算德厄特
        if deerta < 0:
            print("此二次函数无零点")
        elif deerta > 0:
            x_1 = (-b + deerta**0.5) / (2 * a)
            x_2 = (-b - deerta**0.5) / (2 * a)
            if x_n == 0:
                return [x_1, x_2]
            elif x_n == 1:
                return x_1
            elif x_n == 2:
                return x_2
        elif deerta == 0:
            x = -b / 2 * a
            return x
    else:
        x = -b * c
        return x


# 函数的调用和C大致相同，但是有两种调用方法

# 1、位置实参
# 和 C 完全相同
print(solve(1, 6, 3, 1))

# 2、关键字实参
# 通过 名称-值 对，在实参中名称和值关联起来，这样就无需考虑参数的顺序了
print(solve(b=6, a=1, c=3))


# 默认值
# 可以像我的这个函数一样，在定义函数的时候给形参定义上默认值，当省略实参时，将使用形参的默认值

# 函数重载
# python中函数重载很简单，就像我上面的 x_n 那样，把他放在最后然后给他一个默认值即可
# 这么玩的话，随便省略最后几个参数都可以了，前提是函数内做好预备
print(solve(-1, 2))

# 函数可以返回任何对象，列表、字典、字典列表都可以

# 列表的的传参和任何变量的传参一模一样
# 但是但是，不同的是：列表传参可能导致函数将列表给修改了，使得你找不到原列表
# 也就是说，我又释怀了，我还纳闷怎么修改列表，妈的，郁闷半个下午了
# 所以如果你不想把原列表给修改了，尽可能的使用副本传参

# 禁止函数修改列表
# 切片表示法： [:] 将列表切片传上去


#  传递任意量的实参
# 不得不说python确实是个神，这都能给你搞了，那还有什么搞不了的
# *XXXX 在形参名前面加上一个星号，就能让python创建一个名称为 XXXX 的空元组，并将收到的所有的值全都封装在这个空元组中
# 应该把任意数量形参放在函数参数表的最后面


# 将函数储存在模块中（import）
import MyFunction

# 类似于C中的头文件，但是稍有差距
# Python读取这个文件时,将其中的所有函数都复制到这个程序中。
# 当你使用函数时，应当使用：模块名.函数名() 的格式使用函数
print(MyFunction.rank_num(26, 4, 97, 64, 5, 34, 94, 78, 12, 85, 6, 79, 422, 2, 3211))
# 类似于C中的类

# 导入特定的函数
# from 模块名 import 函数名，函数名，函数名
from MyFunction import SayHi, max

# 像这样显式的导入，调用时就不需要写 模块名. 了，直接使用函数即可
# 类似于C中的名称空间namespace
# 使用如下语法：
# from  模块  import *
# 即可导入模块中的所有函数，且使用时无需使用 模块. （句点表示法）

# 使用 as 给函数指定别名
# from 模块 import 函数 as 新名称
from MyFunction import rank_num as RKN

# 这样，函数 rank_num 就可以用 RNK 来表示了
# 适用于函数名很长或者是本文件中有同名函数防止混淆的情况

# 使用 as 给模块指定别名
# import 模块 as 别名
import MyFunction as MF

print(MyFunction.max(2, 56, 8, 7, 5, 456, 3, 484, 5798, 64))
print(MF.rank_num(546, 97, 45, 23, 4, 1554, 89, 32, 964, 1, 32))
# print(MyFunction.RKN(45,9566,23))
# 如上，重命名的函数是不能使用句点表示法表示的，使用句点表示法必须使用函数的原名
# 模板的原名和别名任意替换
